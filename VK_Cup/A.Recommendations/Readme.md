### A.Recommendations

题意描述：给你数组A，同时有数组T。你可以increase A[i] by one with cost T[i]. 我们需要使得最终A的所有元素都不同。问最少的代价是多少。

我们将A的元素按照从小到大排列。假设A[0]是最小的元素（没有之一），那么A[0]显然是不需要做任何操作的（已经与其他任何元素不同）。如果多个元素（比如说k个）的数值都是val，那么我们必然要将这个元素中的k-1个都至少提升1，可以保留一个不用提升。显然，那个这个不用提升的元素，必然是这k个数中cost最大的那个。

然后我们考察数值等于val+1的元素。这些元素包括了之前从val提升1的那些数，也还有一些原本A中数值等于val+1的元素。同理，我们只能保留一个，其余的必须再次提升1.此时保留的那个，就是这个并集中cost最大的那个。

于是我们利用这个思想，可以有o(N^2)的解法，但会TLE。

我们可以优化的地方在于：在上述的第一步中，我们手头其实有一个集合，包括了所有数值是val的元素。根据贪心，除了其中cost最大的那个（假设是i），其余所有的元素都要提升1，此时我们的代价其实就是```cost+=sum-T[i]```，其中sum就是这个集合的cost的总和。

接下来，我们其实要做的操作就是，将T[i]从这个集合中剔除，然后往集合中加入A里所有数值等于val+1的元素。记得在剔除、加入的过程中可以实时更新sum。然后，我们发现，如果这个集合是有序容器，我们就可以很方便地找到cost最大的那个（假设是j），此时就又有```cost+=sum-T[j]```。依次继续，直到集合为空。

考虑到这个有序集合最多加入了n个元素（每个A中的元素只被加入了一次），所以时间复杂度就是o(NlogN).
